/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License
 */

package com.android.tools.build.bundletool.device;

import static com.android.tools.build.bundletool.model.utils.ModuleDependenciesUtils.addModuleDependencies;
import static com.android.tools.build.bundletool.model.utils.ModuleDependenciesUtils.buildAdjacencyMap;
import static com.google.common.base.Preconditions.checkArgument;
import static com.google.common.collect.ImmutableSet.toImmutableSet;

import com.android.bundle.Commands.ApkDescription;
import com.android.bundle.Commands.ApkSet;
import com.android.bundle.Commands.AssetModuleMetadata;
import com.android.bundle.Commands.AssetSliceSet;
import com.android.bundle.Commands.BuildApksResult;
import com.android.bundle.Commands.DeliveryType;
import com.android.bundle.Commands.ModuleMetadata;
import com.android.bundle.Commands.Variant;
import com.android.bundle.Devices.DeviceSpec;
import com.android.bundle.Targeting.ApkTargeting;
import com.android.tools.build.bundletool.model.ModuleSplit;
import com.android.tools.build.bundletool.model.ZipPath;
import com.android.tools.build.bundletool.model.exceptions.CommandExecutionException;
import com.android.tools.build.bundletool.model.exceptions.ValidationException;
import com.android.tools.build.bundletool.model.version.Version;
import com.google.common.base.Predicate;
import com.google.common.base.Predicates;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMultimap;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Sets;
import java.util.HashSet;
import java.util.Optional;
import java.util.Set;

/** Calculates whether a given device can be served an APK generated by the bundle tool. */
public class ApkMatcher {

  private final ImmutableList<? extends TargetingDimensionMatcher<?>> apkMatchers;

  private final Optional<ImmutableSet<String>> requestedModuleNames;
  private final boolean matchInstant;
  private final ModuleMatcher moduleMatcher;
  private final VariantMatcher variantMatcher;

  public ApkMatcher(DeviceSpec deviceSpec) {
    this(deviceSpec, Optional.empty(), /* matchInstant= */ false);
  }

  /**
   * Constructs an ApkMatcher, with a given device configuration, set of splits to match, and an
   * option to match instant splits.
   */
  public ApkMatcher(
      DeviceSpec deviceSpec,
      Optional<ImmutableSet<String>> requestedModuleNames,
      boolean matchInstant) {
    checkArgument(
        !requestedModuleNames.isPresent() || !requestedModuleNames.get().isEmpty(),
        "Set of requested split modules cannot be empty.");
    SdkVersionMatcher sdkVersionMatcher = new SdkVersionMatcher(deviceSpec);
    AbiMatcher abiMatcher = new AbiMatcher(deviceSpec);
    MultiAbiMatcher multiAbiMatcher = new MultiAbiMatcher(deviceSpec);
    ScreenDensityMatcher screenDensityMatcher = new ScreenDensityMatcher(deviceSpec);
    LanguageMatcher languageMatcher = new LanguageMatcher(deviceSpec);
    DeviceFeatureMatcher deviceFeatureMatcher = new DeviceFeatureMatcher(deviceSpec);

    this.apkMatchers =
        ImmutableList.of(
            sdkVersionMatcher, abiMatcher, multiAbiMatcher, screenDensityMatcher, languageMatcher);
    this.requestedModuleNames = requestedModuleNames;
    this.matchInstant = matchInstant;
    this.moduleMatcher = new ModuleMatcher(sdkVersionMatcher, deviceFeatureMatcher);
    this.variantMatcher =
        new VariantMatcher(
            sdkVersionMatcher, abiMatcher, multiAbiMatcher, screenDensityMatcher, matchInstant);
  }

  /**
   * Returns all APKs that should be installed on a device.
   *
   * @param buildApksResult describes APKs produced by the BundleTool
   * @return paths of the matching APKs as represented by {@link ApkDescription#getPath()}
   */
  public ImmutableList<ZipPath> getMatchingApks(BuildApksResult buildApksResult) {
    Optional<Variant> matchingVariant = variantMatcher.getMatchingVariant(buildApksResult);

    if (matchingVariant.isPresent()) {
      validateVariant(matchingVariant.get(), buildApksResult);
    }

    ImmutableList<ZipPath> variantApks =
        matchingVariant.isPresent()
            ? getMatchingApksFromVariant(
                matchingVariant.get(), Version.of(buildApksResult.getBundletool().getVersion()))
            : ImmutableList.of();

    ImmutableList<ZipPath> assetModuleApks = getMatchingApksFromAssetModules(buildApksResult);

    return ImmutableList.<ZipPath>builder().addAll(variantApks).addAll(assetModuleApks).build();
  }

  public ImmutableList<ZipPath> getMatchingApksFromVariant(Variant variant, Version bundleVersion) {
    ImmutableList.Builder<ZipPath> matchedApksBuilder = ImmutableList.builder();

    Predicate<String> moduleNameMatcher = getModuleNameMatcher(variant, bundleVersion);

    for (ApkSet apkSet : variant.getApkSetList()) {
      String moduleName = apkSet.getModuleMetadata().getName();

      for (ApkDescription apkDescription : apkSet.getApkDescriptionList()) {
        ApkTargeting apkTargeting = apkDescription.getTargeting();
        boolean isSplit =
            !apkDescription.hasStandaloneApkMetadata() && !apkDescription.hasApexApkMetadata();

        checkCompatibleWithApkTargeting(apkTargeting);

        if (matchesApk(apkTargeting, isSplit, moduleName, moduleNameMatcher)) {
          matchedApksBuilder.add(ZipPath.create(apkDescription.getPath()));
        }
      }
    }

    return matchedApksBuilder.build();
  }

  private Predicate<String> getModuleNameMatcher(Variant variant, Version bundleVersion) {
    if (requestedModuleNames.isPresent()) {
      ImmutableMultimap<String, String> moduleDependenciesMap = buildAdjacencyMap(variant);

      HashSet<String> dependencyModules = new HashSet<>(requestedModuleNames.get());
      for (String requestedModuleName : requestedModuleNames.get()) {
        addModuleDependencies(requestedModuleName, moduleDependenciesMap, dependencyModules);
      }

      if (matchInstant) {
        return dependencyModules::contains;
      } else {
        return Predicates.or(
            buildModulesDeliveredInstallTime(variant, bundleVersion)::contains,
            dependencyModules::contains);
      }
    } else {
      if (matchInstant) {
        // For instant matching, by default all instant modules are matched.
        return Predicates.alwaysTrue();
      } else {
        // For conventional matching, only install-time modules are matched.
        return buildModulesDeliveredInstallTime(variant, bundleVersion)::contains;
      }
    }
  }

  private void validateVariant(Variant variant, BuildApksResult buildApksResult) {
    if (requestedModuleNames.isPresent()) {
      Set<String> availableModules =
          Sets.union(
              variant.getApkSetList().stream()
                  .map(ApkSet::getModuleMetadata)
                  .map(ModuleMetadata::getName)
                  .collect(toImmutableSet()),
              buildApksResult.getAssetSliceSetList().stream()
                  .map(AssetSliceSet::getAssetModuleMetadata)
                  .map(AssetModuleMetadata::getName)
                  .collect(toImmutableSet()));
      Set<String> unknownModules = Sets.difference(requestedModuleNames.get(), availableModules);
      if (!unknownModules.isEmpty()) {
        throw ValidationException.builder()
            .withMessage(
                "The APK Set archive does not contain the following modules: %s", unknownModules)
            .build();
      }
    }
  }

  /** Builds a list of modules that will be delivered on installation. */
  private ImmutableSet<String> buildModulesDeliveredInstallTime(
      Variant variant, Version bundleVersion) {
    // Module dependency resolution can be skipped because install-time modules can't depend on
    // on-demand modules.
    return variant.getApkSetList().stream()
        .map(ApkSet::getModuleMetadata)
        .filter(moduleMetadata -> willBeDeliveredInstallTime(moduleMetadata, bundleVersion))
        .map(ModuleMetadata::getName)
        .collect(toImmutableSet());
  }

  private boolean willBeDeliveredInstallTime(ModuleMetadata moduleMetadata, Version bundleVersion) {
    boolean installTime =
        bundleVersion.isNewerThan(Version.of("0.10.1"))
            ? moduleMetadata.getDeliveryType().equals(DeliveryType.INSTALL_TIME)
            : !moduleMetadata.getOnDemandDeprecated();

    return installTime && moduleMatcher.matchesModuleTargeting(moduleMetadata.getTargeting());
  }

  /** Returns whether a given APK generated by the Bundle Tool should be installed on a device. */
  private boolean matchesApk(
      ApkTargeting apkTargeting,
      boolean isSplit,
      String moduleName,
      Predicate<String> moduleNameMatcher) {
    boolean matchesTargeting = matchesApkTargeting(apkTargeting);

    if (isSplit) {
      return matchesTargeting && moduleNameMatcher.test(moduleName);
    } else {
      if (matchesTargeting && requestedModuleNames.isPresent()) {
        throw CommandExecutionException.builder()
            .withMessage("Cannot restrict modules when the device matches a non-split APK.")
            .build();
      }
      return matchesTargeting;
    }
  }

  private boolean matchesApkTargeting(ApkTargeting apkTargeting) {
    return apkMatchers.stream()
        .allMatch(matcher -> matcher.getApkTargetingPredicate().test(apkTargeting));
  }

  /**
   * Returns whether a given APK generated by the Bundle Tool matches the device targeting.
   *
   * @return whether the APK matches the device targeting
   */
  public boolean matchesModuleSplitByTargeting(ModuleSplit moduleSplit) {
    // Check device compatibility.
    variantMatcher.checkCompatibleWithVariantTargeting(moduleSplit.getVariantTargeting());
    checkCompatibleWithApkTargeting(moduleSplit.getApkTargeting());

    return variantMatcher.matchesVariantTargeting(moduleSplit.getVariantTargeting())
        && matchesApkTargeting(moduleSplit.getApkTargeting());
  }

  /**
   * Checks if a device is compatible with targeting of a given split, considering the targeting
   * alternatives.
   *
   * @throws IncompatibleDeviceException
   */
  public void checkCompatibleWithApkTargeting(ModuleSplit moduleSplit) {
    checkCompatibleWithApkTargeting(moduleSplit.getApkTargeting());
  }

  private void checkCompatibleWithApkTargeting(ApkTargeting apkTargeting) {
    apkMatchers.forEach(matcher -> checkCompatibleWithApkTargetingHelper(matcher, apkTargeting));
  }

  private <T> void checkCompatibleWithApkTargetingHelper(
      TargetingDimensionMatcher<T> matcher, ApkTargeting apkTargeting) {
    matcher.checkDeviceCompatible(matcher.getTargetingValue(apkTargeting));
  }

  private ImmutableList<ZipPath> getMatchingApksFromAssetModules(BuildApksResult buildApksResult) {
    ImmutableList.Builder<ZipPath> matchedApksBuilder = ImmutableList.builder();

    Predicate<String> assetModuleNameMatcher =
        getInstallTimeAssetModuleNameMatcher(buildApksResult);

    for (AssetSliceSet sliceSet : buildApksResult.getAssetSliceSetList()) {
      String moduleName = sliceSet.getAssetModuleMetadata().getName();
      for (ApkDescription apkDescription : sliceSet.getApkDescriptionList()) {
        ApkTargeting apkTargeting = apkDescription.getTargeting();

        checkCompatibleWithApkTargeting(apkTargeting);

        if (matchesApk(apkTargeting, /*isSplit=*/ true, moduleName, assetModuleNameMatcher)) {
          matchedApksBuilder.add(ZipPath.create(apkDescription.getPath()));
        }
      }
    }
    return matchedApksBuilder.build();
  }

  private Predicate<String> getInstallTimeAssetModuleNameMatcher(BuildApksResult buildApksResult) {
    ImmutableSet<String> upfrontAssetModuleNames =
        buildApksResult.getAssetSliceSetList().stream()
            .filter(
                sliceSet ->
                    sliceSet
                        .getAssetModuleMetadata()
                        .getDeliveryType()
                        .equals(DeliveryType.INSTALL_TIME))
            .map(sliceSet -> sliceSet.getAssetModuleMetadata().getName())
            .collect(toImmutableSet());

    return requestedModuleNames.isPresent()
        ? Sets.intersection(upfrontAssetModuleNames, requestedModuleNames.get())::contains
        : upfrontAssetModuleNames::contains;
  }
}
