/*
 * Copyright (C) 2018 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License
 */

package com.android.tools.build.bundletool.device;

import static com.google.common.collect.ImmutableList.toImmutableList;
import static com.google.common.collect.MoreCollectors.toOptional;
import static java.util.stream.Collectors.partitioningBy;

import com.android.bundle.Commands.ApkDescription;
import com.android.bundle.Commands.BuildApksResult;
import com.android.bundle.Commands.Variant;
import com.android.bundle.Devices.DeviceSpec;
import com.android.bundle.Targeting.VariantTargeting;
import com.google.common.collect.ImmutableList;
import java.util.Map;
import java.util.Optional;
import java.util.function.Supplier;
import java.util.stream.Stream;

/** Calculates whether a given device matched variant generated by the bundle tool. */
public class VariantMatcher {

  private final ImmutableList<? extends TargetingDimensionMatcher<?>> variantMatchers;
  private final boolean matchInstant;
  private final SdkRuntimeMatcher sdkRuntimeMatcher;

  public VariantMatcher(DeviceSpec deviceSpec) {
    this(deviceSpec, /* matchInstant= */ false);
  }

  /**
   * Constructs an VariantMatcher, with a given device configuration, and an option to match instant
   * splits.
   */
  public VariantMatcher(DeviceSpec deviceSpec, boolean matchInstant) {
    this(
        new SdkVersionMatcher(deviceSpec),
        new AbiMatcher(deviceSpec),
        new MultiAbiMatcher(deviceSpec),
        new ScreenDensityMatcher(deviceSpec),
        new TextureCompressionFormatMatcher(deviceSpec),
        new SdkRuntimeMatcher(deviceSpec),
        matchInstant);
  }

  VariantMatcher(
      SdkVersionMatcher sdkVersionMatcher,
      AbiMatcher abiMatcher,
      MultiAbiMatcher multiAbiMatcher,
      ScreenDensityMatcher screenDensityMatcher,
      TextureCompressionFormatMatcher textureCompressionFormatMatcher,
      SdkRuntimeMatcher sdkRuntimeMatcher,
      boolean matchInstant) {
    this.variantMatchers =
        ImmutableList.of(
            sdkVersionMatcher,
            abiMatcher,
            multiAbiMatcher,
            screenDensityMatcher,
            textureCompressionFormatMatcher,
            sdkRuntimeMatcher);
    this.matchInstant = matchInstant;
    this.sdkRuntimeMatcher = sdkRuntimeMatcher;
  }

  /**
   * Returns all variants matching a (partial or full) device-spec. Note that at most one variant
   * can match a full device-spec (generated from device-spec command).
   */
  public ImmutableList<Variant> getAllMatchingVariants(BuildApksResult buildApksResult) {
    if (!sdkRuntimeMatcher.isDeviceDimensionPresent()
        && sdkRuntimeMatcher.deviceSupportsSdkRuntime()) {
      return getAllMatchingVariants(ImmutableList.copyOf(buildApksResult.getVariantList()));
    }

    // Separate SDK runtime and non-sdk runtime variants.
    Map<Boolean, ImmutableList<Variant>> partitionedVariants =
        buildApksResult.getVariantList().stream()
            .collect(
                partitioningBy(
                    variant ->
                        variant.getTargeting().getSdkRuntimeTargeting().getRequiresSdkRuntime(),
                    toImmutableList()));

    // First, try to match variants with SDK runtime targeting. If no SDK Runtime variant matches
    // the device, we fall back to non-sdk runtime variants. This ordering is required because the
    // SdkRuntimeMatcher will match a non-SDK runtime variant to a device that supports the SDK
    // runtime, which is not optimal if there is another variant that targets the SDK runtime.
    if (sdkRuntimeMatcher.deviceSupportsSdkRuntime()) {
      ImmutableList<Variant> matchingSdkRuntimeVariants =
          getAllMatchingVariants(partitionedVariants.get(true));
      if (!matchingSdkRuntimeVariants.isEmpty()) {
        return matchingSdkRuntimeVariants;
      }
    }
    return getAllMatchingVariants(partitionedVariants.get(false));
  }

  private ImmutableList<Variant> getAllMatchingVariants(ImmutableList<Variant> variants) {
    Supplier<Stream<Variant>> variantsToMatch =
        () -> variants.stream().filter(variant -> isVariantInstant(variant) == matchInstant);

    // Check if the device is compatible with the variants.
    variantsToMatch.get().forEach(this::checkCompatibleWithVariant);

    return variantsToMatch
        .get()
        .filter(variant -> matchesVariantTargeting(variant.getTargeting()))
        .collect(toImmutableList());
  }

  /**
   * Returns a single variant matching a full device-spec.
   *
   * @throws IllegalArgumentException if multiple variants are matched.
   */
  public Optional<Variant> getMatchingVariant(BuildApksResult buildApksResult) {
    return getAllMatchingVariants(buildApksResult).stream().collect(toOptional());
  }

  public void checkCompatibleWithVariant(Variant variant) {
    checkCompatibleWithVariantTargeting(variant.getTargeting());
  }

  public void checkCompatibleWithVariantTargeting(VariantTargeting targeting) {
    variantMatchers.stream()
        .forEach(matcher -> checkCompatibleWithVariantTargetingHelper(matcher, targeting));
  }

  public boolean matchesVariantTargeting(VariantTargeting variantTargeting) {
    return variantMatchers.stream()
        .allMatch(matcher -> matcher.getVariantTargetingPredicate().test(variantTargeting));
  }

  private static boolean isVariantInstant(Variant variant) {
    return variant.getApkSetList().stream()
        .flatMap(apkSet -> apkSet.getApkDescriptionList().stream())
        .allMatch(ApkDescription::hasInstantApkMetadata);
  }

  private <T> void checkCompatibleWithVariantTargetingHelper(
      TargetingDimensionMatcher<T> matcher, VariantTargeting variantTargeting) {
    matcher.checkDeviceCompatible(matcher.getTargetingValue(variantTargeting));
  }
}
